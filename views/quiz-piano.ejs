<!DOCTYPE html>
<html lang="en">
<%- include('partials/head') %>

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>和音判定問題</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        height: 100vh;
        margin: 0;
        background-color: #f4f4f4;
        font-family: Arial, sans-serif;
      }

      .keyboard {
        position: relative;
        display: flex;
        width: 800px;
        /* 幅を広げる */
        height: 200px;
        margin-top: 20px;
        background-color: #f1f1f1;
        border: 2px solid #aaa;
        border-radius: 12px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .white-key,
      .black-key {
        display: flex;
        justify-content: center;
        align-items: flex-end;
        font-size: 14px;
        /* フォントサイズを少し小さく */
        font-weight: bold;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.1s;
        border-radius: 4px;
      }

      .white-key {
        width: 7.14%;
        /* 14個の白鍵のため */
        height: 100%;
        background-color: #fff;
        border: 1px solid #ccc;
        box-sizing: border-box;
        position: relative;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .black-key {
        width: 6%;
        height: 60%;
        background-color: #333;
        color: white;
        position: absolute;
        border-radius: 4px;
        z-index: 2;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      /* 1オクターブ目の黒鍵位置 */
      .black-key.c-sharp-1 {
        left: 4.75%;
      }

      .black-key.d-sharp-1 {
        left: 11.75%;
      }

      .black-key.f-sharp-1 {
        left: 26.25%;
      }

      .black-key.g-sharp-1 {
        left: 33.35%;
      }

      .black-key.a-sharp-1 {
        left: 40.5%;
      }

      /* 2オクターブ目の黒鍵位置 */
      .black-key.c-sharp-2 {
        left: 54.75%;
      }

      .black-key.d-sharp-2 {
        left: 61.75%;
      }

      .black-key.f-sharp-2 {
        left: 76.25%;
      }

      .black-key.g-sharp-2 {
        left: 83.35%;
      }

      .black-key.a-sharp-2 {
        left: 90.5%;
      }

      .pressed-white {
        background-color: #e0e0e0 !important;
      }

      .pressed-black {
        background-color: #555 !important;
      }

      /* 他のスタイルは変更なし */
      .start-screen {
        text-align: center;
        padding: 2rem;
        background-color: white;
        border-radius: 12px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        margin: 20px;
        width: 80%;
        max-width: 600px;
      }

      .start-screen div:first-child {
        font-size: 2em;
        font-weight: bold;
        margin-bottom: 1rem;
      }

      .description {
        margin-bottom: 2rem;
        color: #666;
        line-height: 1.5;
      }

      .start-button {
        background-color: #4caf50;
        color: white;
        padding: 1rem 2rem;
        border: none;
        border-radius: 8px;
        font-size: 1.2em;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .start-button:hover {
        background-color: #45a049;
      }

      .end-screen {
        text-align: center;
        padding: 2rem;
        background-color: white;
        border-radius: 12px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        margin: 20px;
        width: 80%;
        max-width: 600px;
      }

      #final-result {
        font-size: 1.5em;
        margin: 1rem 0;
        padding: 1rem;
        background-color: #f8f9fa;
        border-radius: 8px;
      }

      #final-time {
        font-size: 1.2em;
        margin: 1rem 0;
        color: #666;
      }

      .end-button {
        background-color: #4caf50;
        color: white;
        padding: 1rem 2rem;
        border: none;
        border-radius: 8px;
        font-size: 1.2em;
        cursor: pointer;
        transition: background-color 0.3s;
        margin-top: 1rem;
      }

      .end-button:hover {
        background-color: #45a049;
      }

      .midi-status {
        margin: 1rem 0;
        padding: 0.5rem;
        background-color: #f8f9fa;
        border-radius: 8px;
        color: #666;
      }

      /* 和音のヒント色 */
      .hint-white-c3 {
        background-color: #fff7e6 !important;
        /* C3の音階用の薄い黄色 */
      }

      .hint-black-c3 {
        background-color: #4d4d00 !important;
        /* C3の音階用の黒鍵の色 */
      }

      .hint-white-c4 {
        background-color: #e6f7ff !important;
        /* C4の音階用の薄い青色 */
      }

      .hint-black-c4 {
        background-color: #004d4d !important;
        /* C4の音階用の黒鍵の色 */
      }

      .hint-setting {
        margin: 1rem 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .hint-label {
        color: #666;
      }

      /* ヒント機能の設定 */
      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: 0.4s;
      }

      input:checked+.slider {
        background-color: #4caf50;
      }

      input:checked+.slider:before {
        transform: translateX(26px);
      }

      .slider.round {
        border-radius: 34px;
      }

      .slider.round:before {
        border-radius: 50%;
      }

      /* 周波数スペクトラムの色分け */
      .frequency-labels {
        position: absolute;
        bottom: 5px;
        width: 100%;
        display: flex;
        justify-content: space-around;
        font-size: 12px;
        color: #666;
      }

      .note-marker {
        position: absolute;
        font-size: 10px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 4px;
        border-radius: 3px;
        transform: translateX(-50%);
      }

      .legend {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin: 5px 0;
      }

      .legend-color {
        width: 15px;
        height: 15px;
        margin-right: 5px;
        border-radius: 3px;
      }
    </style>
  </head>

  <body>
    <%- include('partials/header') %>
    <%- include('partials/nav') %>
        <!-- スタート画面 -->
        <div class="start-screen" id="start-screen">
          <div>和音判定問題</div>
          <div class="description">
            音楽の和音を学習する問題です。<br />
            鍵盤を押して和音を入力してください！
          </div>
          <div class="midi-status" id="midi-status">
            MIDIキーボードの接続状態: 未接続
          </div>
          <div class="hint-setting">
            <label class="switch">
              <input type="checkbox" id="hint-toggle" checked />
              <span class="slider round"></span>
            </label>
            <span class="hint-label">ヒント表示</span>
          </div>
          <button class="start-button" id="start-button">スタート</button>
        </div>

        <!-- 出題画面 -->
        <div id="game-screen" style="display: none">
          <div class="challenge" id="challenge">問題を読み込み中です</div>
          <div class="input-log" id="input-log">入力： なし</div>
          <div class="result" id="result"></div>
          <div class="timer-container">
            <div class="timer" id="timer">00:00:00.00</div>
            <div class="question-count" id="question-count">0/5</div>
            <canvas id="waveformCanvas" width="800" height="300" style="
            background: #f8f9fa;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          ">
            </canvas>
          </div>

          <!-- GUI鍵盤 -->
          <div class="keyboard" id="keyboard">
            <!-- 1オクターブ目の白鍵 -->
            <div class="white-key" data-note="C3" id="key-C3">C3</div>
            <div class="white-key" data-note="D3" id="key-D3">D3</div>
            <div class="white-key" data-note="E3" id="key-E3">E3</div>
            <div class="white-key" data-note="F3" id="key-F3">F3</div>
            <div class="white-key" data-note="G3" id="key-G3">G3</div>
            <div class="white-key" data-note="A3" id="key-A3">A3</div>
            <div class="white-key" data-note="B3" id="key-B3">B3</div>
            <!-- 2オクターブ目の白鍵 -->
            <div class="white-key" data-note="C4" id="key-C4">C4</div>
            <div class="white-key" data-note="D4" id="key-D4">D4</div>
            <div class="white-key" data-note="E4" id="key-E4">E4</div>
            <div class="white-key" data-note="F4" id="key-F4">F4</div>
            <div class="white-key" data-note="G4" id="key-G4">G4</div>
            <div class="white-key" data-note="A4" id="key-A4">A4</div>
            <div class="white-key" data-note="B4" id="key-B4">B4</div>

            <!-- 1オクターブ目の黒鍵 -->
            <div class="black-key c-sharp-1" data-note="C#3" id="key-C#3">C#3</div>
            <div class="black-key d-sharp-1" data-note="D#3" id="key-D#3">D#3</div>
            <div class="black-key f-sharp-1" data-note="F#3" id="key-F#3">F#3</div>
            <div class="black-key g-sharp-1" data-note="G#3" id="key-G#3">G#3</div>
            <div class="black-key a-sharp-1" data-note="A#3" id="key-A#3">A#3</div>
            <!-- 2オクターブ目の黒鍵 -->
            <div class="black-key c-sharp-2" data-note="C#4" id="key-C#4">C#4</div>
            <div class="black-key d-sharp-2" data-note="D#4" id="key-D#4">D#4</div>
            <div class="black-key f-sharp-2" data-note="F#4" id="key-F#4">F#4</div>
            <div class="black-key g-sharp-2" data-note="G#4" id="key-G#4">G#4</div>
            <div class="black-key a-sharp-2" data-note="A#4" id="key-A#4">A#4</div>
          </div>
        </div>
        <!-- 結果画面 -->
        <div id="end-screen" class="end-screen" style="display: none">
          <div id="final-result"></div>
          <div id="final-time">経過時間： 00:00:00.00</div>
          <button class="end-button" id="end-button">もう一度</button>
        </div>

        <script>
          // オーディオファイルの定義
          const audioFiles = {
            'C3': 'audio/C3.wav',
            'C#3': 'audio/Cs3.wav',
            'D3': 'audio/D3.wav',
            'D#3': 'audio/Ds3.wav',
            'E3': 'audio/E3.wav',
            'F3': 'audio/F3.wav',
            'F#3': 'audio/Fs3.wav',
            'G3': 'audio/G3.wav',
            'G#3': 'audio/Gs3.wav',
            'A3': 'audio/A3.wav',
            'A#3': 'audio/As3.wav',
            'B3': 'audio/B3.wav',
            'C4': 'audio/C4.wav',
            'C#4': 'audio/Cs4.wav',
            'D4': 'audio/D4.wav',
            'D#4': 'audio/Ds4.wav',
            'E4': 'audio/E4.wav',
            'F4': 'audio/F4.wav',
            'F#4': 'audio/Fs4.wav',
            'G4': 'audio/G4.wav',
            'G#4': 'audio/Gs4.wav',
            'A4': 'audio/A4.wav',
            'A#4': 'audio/As4.wav',
            'B4': 'audio/B4.wav'
          };

          // 音声を管理するクラス
          class SoundPlayer {
            constructor() {
              this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
              this.buffers = new Map();
              this.loading = false;

              this.analyser = this.audioContext.createAnalyser();
              this.analyser.fftSize = 4096;
              this.analyser.minDecibels = -100;
              this.analyser.maxDecibels = 0;
              this.analyser.smoothingTimeConstant = 0.85;
              this.analyser.connect(this.audioContext.destination);

              this.canvas = document.getElementById("waveformCanvas");
              this.canvasCtx = this.canvas.getContext("2d");
              this.waveformData = new Uint8Array(this.analyser.frequencyBinCount);
              this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
              this.isDrawing = false;

              // 周波数範囲の設定
              this.freqRange = {
                min: 20,
                max: 4000
              };

              // グラデーションの色設定
              this.gradientColors = {
                start: "#3498DB",  // 低周波（青）
                middle: "#2ECC71",  // 中周波（緑）
                end: "#E74C3C"   // 高周波（赤）
              };

              // ラベル設定
              this.labels = [
                { freq: 110, label: "低周波" },
                { freq: 500, label: "中周波" },
                { freq: 2000, label: "高周波" }
              ];
            }

            async loadaudio() {
              if (this.loading) return;
              this.loading = true;

              try {
                await Promise.all(
                  Object.entries(audioFiles).map(async ([note, path]) => {
                    const response = await fetch(path);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.buffers.set(note, audioBuffer);
                  })
                );
              } catch (error) {
                console.error("Error loading audio:", error);
              }

              this.loading = false;
            }

            playNote(note) {
              const buffer = this.buffers.get(note);
              if (!buffer) return;

              const source = this.audioContext.createBufferSource();
              source.buffer = buffer;
              source.connect(this.analyser);
              source.start(0);

              if (!this.isDrawing) {
                this.isDrawing = true;
                this.drawVisualization();
              }
            }

            drawVisualization() {
              const draw = () => {
                if (!this.isDrawing) return;
                requestAnimationFrame(draw);

                const width = this.canvas.width;
                const height = this.canvas.height;

                // キャンバスをクリア
                this.canvasCtx.fillStyle = "#f8f9fa";
                this.canvasCtx.fillRect(0, 0, width, height);

                // データを取得
                this.analyser.getByteTimeDomainData(this.waveformData);
                this.analyser.getByteFrequencyData(this.frequencyData);

                // 波形の描画（上部40%）
                this.drawWaveform(width, height);

                // 周波数スペクトラムの描画（下部60%）
                this.drawSpectrum(width, height);
              };

              draw();
            }

            drawWaveform(width, height) {
              const waveformHeight = height * 0.4;

              this.canvasCtx.lineWidth = 3;
              this.canvasCtx.strokeStyle = "#2196F3";
              this.canvasCtx.beginPath();

              const sliceWidth = width / this.analyser.frequencyBinCount;
              let x = 0;

              for (let i = 0; i < this.analyser.frequencyBinCount; i++) {
                const v = this.waveformData[i] / 128.0;
                const y = v * waveformHeight;

                if (i === 0) {
                  this.canvasCtx.moveTo(x, y);
                } else {
                  this.canvasCtx.lineTo(x, y);
                }
                x += sliceWidth;
              }

              this.canvasCtx.stroke();

              // 波形と周波数スペクトラムの区切り（細い線）
              this.canvasCtx.strokeStyle = "rgba(0,0,0,0.05)";
              this.canvasCtx.lineWidth = 1;
              this.canvasCtx.beginPath();
              this.canvasCtx.moveTo(0, waveformHeight);
              this.canvasCtx.lineTo(width, waveformHeight);
              this.canvasCtx.stroke();
            }

            createFrequencyGradient(x, y, width, height) {
              const gradient = this.canvasCtx.createLinearGradient(x, 0, x + width, 0);
              gradient.addColorStop(0, this.gradientColors.start);
              gradient.addColorStop(0.5, this.gradientColors.middle);
              gradient.addColorStop(1, this.gradientColors.end);
              return gradient;
            }

            drawSpectrum(width, height) {
              const spectrumTop = height * 0.4;
              const spectrumHeight = height * 0.6;

              const nyquist = this.audioContext.sampleRate / 2;
              const frequencyBinCount = this.analyser.frequencyBinCount;

              // 周波数データの最大値を取得してスケーリング
              let maxValue = 0;
              for (let i = 0; i < frequencyBinCount; i++) {
                maxValue = Math.max(maxValue, this.frequencyData[i]);
              }
              const scaleFactor = maxValue > 0 ? 255 / maxValue : 1;

              // グラデーションを作成
              const gradient = this.createFrequencyGradient(0, 0, width, spectrumHeight);
              this.canvasCtx.fillStyle = gradient;

              // スペクトラムの描画
              for (let i = 0; i < frequencyBinCount; i++) {
                const frequency = (i * nyquist) / frequencyBinCount;

                if (frequency >= this.freqRange.min && frequency <= this.freqRange.max) {
                  // 周波数に応じた増幅を適用
                  let value = this.frequencyData[i];

                  // 対数スケーリングを適用
                  value = value * Math.log10(frequency + 1) / Math.log10(this.freqRange.max + 1);

                  // 周波数帯域に応じた増幅
                  const freqRatio = (Math.log10(frequency) - Math.log10(this.freqRange.min)) /
                    (Math.log10(this.freqRange.max) - Math.log10(this.freqRange.min));
                  const amplification = 1 + (freqRatio * 0.5); // 高周波になるほど増幅
                  value = value * amplification;

                  // 正規化
                  value = Math.min(255, value * scaleFactor);

                  const percent = value / 255;
                  const barHeight = spectrumHeight * percent;

                  // バーの位置を対数スケールで計算
                  const barX = width * (Math.log10(frequency) - Math.log10(this.freqRange.min)) /
                    (Math.log10(this.freqRange.max) - Math.log10(this.freqRange.min));
                  const barWidth = 2;

                  this.canvasCtx.fillRect(
                    barX,
                    spectrumTop + (spectrumHeight - barHeight),
                    barWidth,
                    barHeight
                  );
                }
              }

              this.drawFrequencyLabels(width, height);
            }

            drawFrequencyLabels(width, height) {
              const spectrumTop = height * 0.4;
              const spectrumHeight = height * 0.6;

              // ラベルの背景
              this.canvasCtx.fillStyle = "rgba(255,255,255,0.9)";
              this.canvasCtx.fillRect(0, height - 30, width, 30);

              // 区切り線を描画
              this.canvasCtx.strokeStyle = "rgba(0,0,0,0.1)";
              this.canvasCtx.lineWidth = 1;

              // 各ラベルの位置に線を描画
              this.labels.forEach(({ freq, label }) => {
                const x = width * (Math.log10(freq) - Math.log10(this.freqRange.min)) /
                  (Math.log10(this.freqRange.max) - Math.log10(this.freqRange.min));

                // 垂直線を描画（点線で表現）
                this.canvasCtx.setLineDash([5, 3]);  // 点線のパターンを設定
                this.canvasCtx.beginPath();
                this.canvasCtx.moveTo(x, spectrumTop);
                this.canvasCtx.lineTo(x, height - 30);
                this.canvasCtx.stroke();
                this.canvasCtx.setLineDash([]); // 点線をリセット

                // ラベルの背景を描画
                this.canvasCtx.fillStyle = "rgba(255,255,255,0.95)";
                this.canvasCtx.fillRect(x - 40, height - 25, 80, 20);

                // ラベルテキストを描画
                this.canvasCtx.font = "14px Arial";
                this.canvasCtx.textAlign = "center";
                const color = this.getGradientColorForFrequency(freq);
                this.canvasCtx.fillStyle = color;
                this.canvasCtx.fillText(label, x, height - 10);
              });

              // 周波数範囲の表示
              this.canvasCtx.font = "10px Arial";
              this.canvasCtx.fillStyle = "rgba(0,0,0,0.5)";
              this.canvasCtx.textAlign = "left";
              this.canvasCtx.fillText(`${this.freqRange.min}Hz`, 5, height - 10);
              this.canvasCtx.textAlign = "right";
              this.canvasCtx.fillText(`${this.freqRange.max}Hz`, width - 5, height - 10);
            }

            getGradientColorForFrequency(freq) {
              const ratio = (Math.log10(freq) - Math.log10(this.freqRange.min)) /
                (Math.log10(this.freqRange.max) - Math.log10(this.freqRange.min));
              if (ratio <= 0.5) {
                return this.lerpColor(this.gradientColors.start, this.gradientColors.middle, ratio * 2);
              } else {
                return this.lerpColor(this.gradientColors.middle, this.gradientColors.end, (ratio - 0.5) * 2);
              }
            }

            // 色の補間計算
            lerpColor(color1, color2, ratio) {
              const r1 = parseInt(color1.slice(1, 3), 16);
              const g1 = parseInt(color1.slice(3, 5), 16);
              const b1 = parseInt(color1.slice(5, 7), 16);

              const r2 = parseInt(color2.slice(1, 3), 16);
              const g2 = parseInt(color2.slice(3, 5), 16);
              const b2 = parseInt(color2.slice(5, 7), 16);

              const r = Math.round(r1 + (r2 - r1) * ratio);
              const g = Math.round(g1 + (g2 - g1) * ratio);
              const b = Math.round(b1 + (b2 - b1) * ratio);

              return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            stopDrawing() {
              this.isDrawing = false;
            }
          }

          // SoundPlayerのインスタンスを生成
          const soundPlayer = new SoundPlayer();

          // コード定義
          const chordDefinitions = {
            // C
            C: ["C3", "E3", "G3"],
            Cm: ["C3", "Eb3", "G3"],
            Caug: ["C3", "E3", "G#3"],
            C6: ["C3", "E3", "G3", "A3"],
            Cm6: ["C3", "Eb3", "G3", "A3"],
            C7: ["C3", "E3", "G3", "Bb3"],
            Cmaj7: ["C3", "E3", "G3", "B3"],
            Cm7: ["C3", "Eb3", "G3", "Bb3"],
            Cm7b5: ["C3", "Eb3", "Gb3", "Bb3"],
            C7sus4: ["C3", "F3", "G3", "Bb3"],
            Cdim7: ["C3", "Eb3", "Gb3", "A3"],
            C9: ["C3", "E3", "G3", "Bb3", "D4"],
            Cmaj9: ["C3", "E3", "G3", "B3", "D4"],
            Cm9: ["C3", "Eb3", "G3", "Bb3", "D4"],

            // D
            D: ["D3", "F#3", "A3"],
            Dm: ["D3", "F3", "A3"],
            Daug: ["D3", "F#3", "A#3"],
            D6: ["D3", "F#3", "A3", "B3"],
            Dm6: ["D3", "F3", "A3", "B3"],
            D7: ["D3", "F#3", "A3", "C4"],
            Dmaj7: ["D3", "F#3", "A3", "C#4"],
            Dm7: ["D3", "F3", "A3", "C4"],
            Dm7b5: ["D3", "F3", "Ab3", "C4"],
            D7sus4: ["D3", "G3", "A3", "C4"],
            Ddim7: ["D3", "F3", "Ab3", "B3"],
            D9: ["D3", "F#3", "A3", "C4", "E4"],
            Dmaj9: ["D3", "F#3", "A3", "C#4", "E4"],
            Dm9: ["D3", "F3", "A3", "C4", "E4"],

            // E
            E: ["E3", "G#3", "B3"],
            Em: ["E3", "G3", "B3"],
            Eaug: ["E3", "G#3", "C4"],
            E6: ["E3", "G#3", "B3", "C#4"],
            Em6: ["E3", "G3", "B3", "C#4"],
            E7: ["E3", "G#3", "B3", "D4"],
            Emaj7: ["E3", "G#3", "B3", "D#4"],
            Em7: ["E3", "G3", "B3", "D4"],
            Em7b5: ["E3", "G3", "Bb3", "D4"],
            E7sus4: ["E3", "A3", "B3", "D4"],
            Edim7: ["E3", "G3", "Bb3", "C#4"],
            E9: ["E3", "G#3", "B3", "D4", "F#4"],
            Emaj9: ["E3", "G#3", "B3", "D#4", "F#4"],
            Em9: ["E3", "G3", "B3", "D4", "F#4"],

            // F
            F: ["F3", "A3", "C4"],
            Fm: ["F3", "Ab3", "C4"],
            Faug: ["F3", "A3", "C#4"],
            F6: ["F3", "A3", "C4", "D4"],
            Fm6: ["F3", "Ab3", "C4", "D4"],
            F7: ["F3", "A3", "C4", "Eb4"],
            Fmaj7: ["F3", "A3", "C4", "E4"],
            Fm7: ["F3", "Ab3", "C4", "Eb4"],
            Fm7b5: ["F3", "Ab3", "B3", "Eb4"],
            F7sus4: ["F3", "Bb3", "C4", "Eb4"],
            Fdim7: ["F3", "Ab3", "B3", "D4"],
            F9: ["F3", "A3", "C4", "Eb4", "G4"],
            Fmaj9: ["F3", "A3", "C4", "E4", "G4"],
            Fm9: ["F3", "Ab3", "C4", "Eb4", "G4"],

            // G
            G: ["G3", "B3", "D4"],
            Gm: ["G3", "Bb3", "D4"],
            Gaug: ["G3", "B3", "D#4"],
            G6: ["G3", "B3", "D4", "E4"],
            Gm6: ["G3", "Bb3", "D4", "E4"],
            G7: ["G3", "B3", "D4", "F4"],
            Gmaj7: ["G3", "B3", "D4", "F#4"],
            Gm7: ["G3", "Bb3", "D4", "F4"],
            Gm7b5: ["G3", "Bb3", "Db4", "F4"],
            G7sus4: ["G3", "C4", "D4", "F4"],
            Gdim7: ["G3", "Bb3", "Db4", "E4"],
            G9: ["G3", "B3", "D4", "F4", "A4"],
            Gmaj9: ["G3", "B3", "D4", "F#4", "A4"],
            Gm9: ["G3", "Bb3", "D4", "F4", "A4"],

            // A
            A: ["A3", "C#4", "E4"],
            Am: ["A3", "C4", "E4"],
            Aaug: ["A3", "C#4", "F4"],
            A6: ["A3", "C#4", "E4", "F#4"],
            Am6: ["A3", "C4", "E4", "F#4"],
            A7: ["A3", "C#4", "E4", "G4"],
            Amaj7: ["A3", "C#4", "E4", "G#4"],
            Am7: ["A3", "C4", "E4", "G4"],
            Am7b5: ["A3", "C4", "Eb4", "G4"],
            A7sus4: ["A3", "D4", "E4", "G4"],
            Adim7: ["A3", "C4", "Eb4", "F#4"],
            A9: ["A3", "C#4", "E4", "G4", "B4"],
            Amaj9: ["A3", "C#4", "E4", "G#4", "B4"],
            Am9: ["A3", "C4", "E4", "G4", "B4"],

            // B
            B: ["B3", "D#4", "F#4"],
            Bm: ["B3", "D4", "F#4"],
            Baug: ["B3", "D#4", "G4"],
            B6: ["B3", "D#4", "F#4", "G#4"],
            Bm6: ["B3", "D4", "F#4", "G#4"],
            B7: ["B3", "D#4", "F#4", "A4"],
            Bmaj7: ["B3", "D#4", "F#4", "A#4"],
            Bm7: ["B3", "D4", "F#4", "A4"],
            Bm7b5: ["B3", "D4", "F4", "A4"],
            B7sus4: ["B3", "E4", "F#4", "A4"],
            Bdim7: ["B3", "D4", "F4", "Ab4"],
            B9: ["B3", "D#4", "F#4", "A4"],  // B9は範囲外のC#5が必要なため、省略
            Bmaj9: ["B3", "D#4", "F#4", "A#4"],  // Bmaj9は範囲外のC#5が必要なため、省略
            Bm9: ["B3", "D4", "F#4", "A4"]  // Bm9は範囲外のC#5が必要なため、省略
          };

          const problems = [
            // C
            { type: "chord", chord: "C" },
            { type: "chord", chord: "Cm" },
            { type: "chord", chord: "Caug" },
            { type: "chord", chord: "C6" },
            { type: "chord", chord: "Cm6" },
            { type: "chord", chord: "C7" },
            { type: "chord", chord: "Cmaj7" },
            { type: "chord", chord: "Cm7" },
            { type: "chord", chord: "Cm7b5" },
            { type: "chord", chord: "C7sus4" },
            { type: "chord", chord: "Cdim7" },
            { type: "chord", chord: "C9" },
            { type: "chord", chord: "Cmaj9" },
            { type: "chord", chord: "Cm9" },

            // D
            { type: "chord", chord: "D" },
            { type: "chord", chord: "Dm" },
            { type: "chord", chord: "Daug" },
            { type: "chord", chord: "D6" },
            { type: "chord", chord: "Dm6" },
            { type: "chord", chord: "D7" },
            { type: "chord", chord: "Dmaj7" },
            { type: "chord", chord: "Dm7" },
            { type: "chord", chord: "Dm7b5" },
            { type: "chord", chord: "D7sus4" },
            { type: "chord", chord: "Ddim7" },
            { type: "chord", chord: "D9" },
            { type: "chord", chord: "Dmaj9" },
            { type: "chord", chord: "Dm9" },

            // E
            { type: "chord", chord: "E" },
            { type: "chord", chord: "Em" },
            { type: "chord", chord: "Eaug" },
            { type: "chord", chord: "E6" },
            { type: "chord", chord: "Em6" },
            { type: "chord", chord: "E7" },
            { type: "chord", chord: "Emaj7" },
            { type: "chord", chord: "Em7" },
            { type: "chord", chord: "Em7b5" },
            { type: "chord", chord: "E7sus4" },
            { type: "chord", chord: "Edim7" },
            { type: "chord", chord: "E9" },
            { type: "chord", chord: "Emaj9" },
            { type: "chord", chord: "Em9" },

            // F
            { type: "chord", chord: "F" },
            { type: "chord", chord: "Fm" },
            { type: "chord", chord: "Faug" },
            { type: "chord", chord: "F6" },
            { type: "chord", chord: "Fm6" },
            { type: "chord", chord: "F7" },
            { type: "chord", chord: "Fmaj7" },
            { type: "chord", chord: "Fm7" },
            { type: "chord", chord: "Fm7b5" },
            { type: "chord", chord: "F7sus4" },
            { type: "chord", chord: "Fdim7" },
            { type: "chord", chord: "F9" },
            { type: "chord", chord: "Fmaj9" },
            { type: "chord", chord: "Fm9" },

            // G
            { type: "chord", chord: "G" },
            { type: "chord", chord: "Gm" },
            { type: "chord", chord: "Gaug" },
            { type: "chord", chord: "G6" },
            { type: "chord", chord: "Gm6" },
            { type: "chord", chord: "G7" },
            { type: "chord", chord: "Gmaj7" },
            { type: "chord", chord: "Gm7" },
            { type: "chord", chord: "Gm7b5" },
            { type: "chord", chord: "G7sus4" },
            { type: "chord", chord: "Gdim7" },
            { type: "chord", chord: "G9" },
            { type: "chord", chord: "Gmaj9" },
            { type: "chord", chord: "Gm9" },

            // A
            { type: "chord", chord: "A" },
            { type: "chord", chord: "Am" },
            { type: "chord", chord: "Aaug" },
            { type: "chord", chord: "A6" },
            { type: "chord", chord: "Am6" },
            { type: "chord", chord: "A7" },
            { type: "chord", chord: "Amaj7" },
            { type: "chord", chord: "Am7" },
            { type: "chord", chord: "Am7b5" },
            { type: "chord", chord: "A7sus4" },
            { type: "chord", chord: "Adim7" },
            { type: "chord", chord: "A9" },
            { type: "chord", chord: "Amaj9" },
            { type: "chord", chord: "Am9" },

            // B
            { type: "chord", chord: "B" },
            { type: "chord", chord: "Bm" },
            { type: "chord", chord: "Baug" },
            { type: "chord", chord: "B6" },
            { type: "chord", chord: "Bm6" },
            { type: "chord", chord: "B7" },
            { type: "chord", chord: "Bmaj7" },
            { type: "chord", chord: "Bm7" },
            { type: "chord", chord: "Bm7b5" },
            { type: "chord", chord: "B7sus4" },
            { type: "chord", chord: "Bdim7" },
            { type: "chord", chord: "B9" },
            { type: "chord", chord: "Bmaj9" },
            { type: "chord", chord: "Bm9" },
          ];

          const challengeDiv = document.getElementById("challenge");
          const inputLogDiv = document.getElementById("input-log");
          const resultDiv = document.getElementById("result");
          const timerDiv = document.getElementById("timer");
          const keyElements = {};

          document.querySelectorAll('.white-key, .black-key').forEach(key => {
            key.addEventListener('mousedown', function () {
              const noteName = this.dataset.note;  // オクターブ情報を含む完全な音名を取得
              if (!userInput.has(noteName)) {  // 重複入力を防ぐ
                userInput.add(noteName);

                // 音を鳴らす
                soundPlayer.playNote(noteName);

                // キーの見た目を更新
                this.classList.add(noteName.includes('#') ? 'pressed-black' : 'pressed-white');

                // 入力表示を更新（オクターブ情報を含めて表示）
                inputLogDiv.textContent = `入力: ${[...userInput].join(", ")}`;

                // 和音の音数が一致したら判定
                if (userInput.size === chordDefinitions[currentProblem.chord].length) {
                  checkAnswer();
                }
              }
            });

            key.addEventListener('mouseup', function () {
              const noteName = this.dataset.note;
              this.classList.remove(noteName.includes('#') ? 'pressed-black' : 'pressed-white');
            });
          });

          let currentProblem = {};
          let userInput = new Set();
          let score = { correct: 0, incorrect: 0 };
          let questionCount = 0;
          let timerInterval;
          let startTime = 0;

          // スタートボタンをクリックした時の処理
          document.getElementById("start-button").addEventListener("click", function () {
            // スコアと問題数を初期化
            score = { correct: 0, incorrect: 0 };
            questionCount = 0;

            clearChordHint();
            document.getElementById("start-screen").style.display = "none";
            document.getElementById("game-screen").style.display = "block";
            nextQuestion();
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 10);
          });

          // 終了ボタンをクリックした時の処理
          document.getElementById("end-button").addEventListener("click", function () {
            score = { correct: 0, incorrect: 0 };
            questionCount = 0;
            userInput.clear();
            clearInterval(timerInterval);
            clearChordHint();
            document.getElementById("end-screen").style.display = "none";
            document.getElementById("start-screen").style.display = "block";
          });

          // タイマー更新
          function updateTimer() {
            const elapsedTime = Date.now() - startTime;
            const hours = String(Math.floor(elapsedTime / 3600000)).padStart(
              2,
              "0"
            );
            const minutes = String(
              Math.floor((elapsedTime % 3600000) / 60000)
            ).padStart(2, "0");
            const seconds = String(
              Math.floor((elapsedTime % 60000) / 1000)
            ).padStart(2, "0");
            const milliseconds = String(
              Math.floor((elapsedTime % 1000) / 10)
            ).padStart(2, "0");

            timerDiv.innerHTML = `
        <span class="timer-unit">${hours}</span>
        <span class="timer-separator">時</span>
        <span class="timer-unit">${minutes}</span>
        <span class="timer-separator">分</span>
        <span class="timer-unit">${seconds}</span>
        <span class="timer-separator">秒</span>
        <span class="timer-ms">${milliseconds}</span>
      `;
          }

          // グローバル変数として追加
          let hintEnabled = true;

          // ヒントの表示制御関数
          function showChordHint(chordName) {
            if (!hintEnabled || !chordName || !chordDefinitions[chordName]) return;

            // まず既存のヒントをクリア
            clearChordHint();

            // 和音の構成音を取得
            const notes = chordDefinitions[chordName];

            // 各音に対してヒントを表示
            notes.forEach(note => {
              const keyElement = document.getElementById(`key-${note}`);
              if (keyElement) {
                const isBlackKey = note.includes('#');
                const octave = note.slice(-1);
                keyElement.classList.add(
                  isBlackKey ? `hint-black-c${octave}` : `hint-white-c${octave}`
                );
              }
            });
          }

          // 転回形を生成する関数
          function generateInversions(notes) {
            const inversions = [];
            const baseNotes = notes.map((note) => note.replace(/[0-9]/g, "")); // オクターブを除去

            // 基本形
            inversions.push(
              baseNotes.map(
                (note, i) => `${note}${i < baseNotes.length / 2 ? "3" : "4"}`
              )
            );

            // 転回形を生成
            for (let i = 1; i < baseNotes.length; i++) {
              const inversion = [...baseNotes.slice(i), ...baseNotes.slice(0, i)];
              inversions.push(
                inversion.map(
                  (note, j) => `${note}${j < inversion.length / 2 ? "3" : "4"}`
                )
              );
            }

            return inversions;
          }

          // ヒントをクリアする関数
          function clearChordHint() {
            document.querySelectorAll('.white-key, .black-key').forEach(key => {
              key.classList.remove('hint-white-c3', 'hint-black-c3', 'hint-white-c4', 'hint-black-c4');
            });
          }

          // ヒント設定の初期化とイベントリスナーの追加
          document.addEventListener('DOMContentLoaded', function () {
            const hintToggle = document.getElementById('hint-toggle');

            hintEnabled = hintToggle.checked;

            hintToggle.addEventListener('change', function () {
              hintEnabled = this.checked;
              if (!hintEnabled) {
                clearChordHint();
              } else if (currentProblem.chord) {
                showChordHint(currentProblem.chord);
              }
            });
          });



          let totalQuestions = 10; // 定数として問題数を定義

          // 問題を更新する関数を修正
          function nextQuestion() {
            if (questionCount >= totalQuestions) {
              clearChordHint();
              showResult();
              return;
            }

            // 現在のヒントをクリア
            clearChordHint();

            // 新しい問題を設定
            const randomProblem = problems[Math.floor(Math.random() * problems.length)];
            currentProblem = randomProblem;

            // UI更新
            challengeDiv.textContent = `${currentProblem.chord}コードを入力してください`;
            userInput.clear();
            inputLogDiv.textContent = "入力: なし";
            resultDiv.textContent = "";
            questionCount++;
            updateQuestionCount();

            // 新しい問題のヒントを表示（ヒントが有効な場合のみ）
            if (hintEnabled) {
              showChordHint(currentProblem.chord);
            }
          }

          // 現在の問題数を更新
          function updateQuestionCount() {
            const questionCountDiv = document.getElementById("question-count");
            questionCountDiv.textContent = `${questionCount}/${totalQuestions}`;
          }

          // 回答判定
          function checkAnswer() {
            if (questionCount > totalQuestions) return;

            const correctNotes = chordDefinitions[currentProblem.chord];
            const userNotes = [...userInput];

            // 音数と位置（オクターブ含む）が完全一致するかチェック
            const isCorrect = correctNotes.length === userNotes.length &&
              userNotes.every(note => correctNotes.includes(note));

            if (isCorrect) {
              score.correct++;
              resultDiv.textContent = "正解！";
              resultDiv.style.color = "green";
            } else {
              score.incorrect++;
              resultDiv.textContent = "不正解！";
              resultDiv.style.color = "red";

              // デバッグ用：正解と入力内容を表示
              console.log("正解の和音:", correctNotes);
              console.log("入力された和音:", userNotes);
            }

            if (questionCount < totalQuestions) {
              setTimeout(() => {
                clearChordHint();
                nextQuestion();
              }, 1000);
            } else {
              setTimeout(() => {
                clearChordHint();
                showResult();
              }, 1000);
            }
          }

          // 結果表示
          function showResult() {
            clearInterval(timerInterval);
            clearChordHint(); // 結果画面表示時にヒントをクリア
            document.getElementById("game-screen").style.display = "none";
            document.getElementById("end-screen").style.display = "block";
            document.getElementById(
              "final-result"
            ).textContent = `正解: ${score.correct}問, 不正解: ${score.incorrect}問`;
            document.getElementById(
              "final-time"
            ).innerHTML = `経過時間: ${timerDiv.innerHTML}`;
          }

          // MIDIメッセージを処理する
          function handleMIDIMessage(message) {
            const [status, note, velocity] = message.data;
            let noteName = midiNoteToNoteName[note];

            // キーを押した時の処理
            if (status === 144 && velocity > 0 && noteName) {
              userInput.add(noteName);  // オクターブ情報を含めて保存

              // 音を鳴らす
              soundPlayer.playNote(noteName);

              // キー表示の更新
              keyElements[noteName]?.classList.add(
                noteName.includes("#") ? "pressed-black" : "pressed-white"
              );

              // 入力表示を更新
              inputLogDiv.textContent = `入力: ${[...userInput].join(", ")}`;

              // 和音の音数が一致したら判定
              if (userInput.size === chordDefinitions[currentProblem.chord].length) {
                checkAnswer();
              }
            }
            // キーを離した時の処理
            else if (status === 128 || (status === 144 && velocity === 0)) {
              keyElements[noteName]?.classList.remove(
                noteName.includes("#") ? "pressed-black" : "pressed-white"
              );
            }
          }

          // 和音の正誤判定を行う補助関数
          function isChordCorrect(inputNotes, correctNotes) {
            // 音名の同値判定用のマッピング
            const equivalentNotes = {
              "C#": "Db",
              Db: "C#",
              "D#": "Eb",
              Eb: "D#",
              "F#": "Gb",
              Gb: "F#",
              "G#": "Ab",
              Ab: "G#",
              "A#": "Bb",
              Bb: "A#",
            };

            // 入力された音がすべて正解の音と一致するかチェック
            return correctNotes.every((correctNote) => {
              return [...inputNotes].some((inputNote) => {
                // 直接一致
                if (inputNote === correctNote) return true;
                // 異名同音での一致
                if (equivalentNotes[inputNote] === correctNote) return true;
                // オクターブ違いでの一致
                const baseInputNote = inputNote.replace(/[0-9]/g, "");
                const baseCorrectNote = correctNote.replace(/[0-9]/g, "");
                return (
                  baseInputNote === baseCorrectNote ||
                  equivalentNotes[baseInputNote] === baseCorrectNote
                );
              });
            });
          }

          // 回答の処理を行う関数
          function handleAnswer(isCorrect) {
            if (isCorrect) {
              score.correct++;
              resultDiv.textContent = "正解！";
              resultDiv.style.color = "green";
            } else {
              score.incorrect++;
              resultDiv.textContent = "不正解！";
              resultDiv.style.color = "red";
            }
            setTimeout(nextQuestion, 1000);
          }

          const midiNoteToNoteName = {
            // 1オクターブ目 (C3-B3)
            48: "C3",
            49: "C#3",
            50: "D3",
            51: "D#3",
            52: "E3",
            53: "F3",
            54: "F#3",
            55: "G3",
            56: "G#3",
            57: "A3",
            58: "A#3",
            59: "B3",
            // 2オクターブ目 (C4-B4)
            60: "C4",
            61: "C#4",
            62: "D4",
            63: "D#4",
            64: "E4",
            65: "F4",
            66: "F#4",
            67: "G4",
            68: "G#4",
            69: "A4",
            70: "A#4",
            71: "B4",
          };
          // MIDIの初期化
          function initMIDI() {
            const midiStatusDiv = document.getElementById("midi-status");

            if (navigator.requestMIDIAccess) {
              navigator
                .requestMIDIAccess()
                .then((access) => {
                  // Setを使用して重複を防ぐ
                  const devices = new Set();

                  // 接続されているデバイスを確認
                  for (let input of access.inputs.values()) {
                    devices.add(input.name || "名称不明のMIDIデバイス");
                    input.onmidimessage = handleMIDIMessage;
                  }

                  // デバイス情報を表示
                  if (devices.size > 0) {
                    midiStatusDiv.textContent = `接続中のMIDIキーボード： ${[
                      ...devices,
                    ].join(", ")}`;
                    midiStatusDiv.style.color = "#2e7d32";
                  } else {
                    midiStatusDiv.textContent =
                      "MIDIキーボードが接続されていません";
                    midiStatusDiv.style.color = "#c62828";
                  }

                  // MIDIデバイスの接続/切断を監視
                  access.onstatechange = function (e) {
                    if (e.port.type === "input") {
                      if (e.port.state === "connected") {
                        devices.add(e.port.name || "名称不明のMIDIデバイス");
                        e.port.onmidimessage = handleMIDIMessage;
                      } else {
                        devices.delete(e.port.name);
                      }

                      // 状態表示を更新
                      if (devices.size > 0) {
                        midiStatusDiv.textContent = `接続中のMIDIキーボード: ${[
                          ...devices,
                        ].join(", ")}`;
                        midiStatusDiv.style.color = "#2e7d32";
                      } else {
                        midiStatusDiv.textContent =
                          "MIDIキーボードが接続されていません";
                        midiStatusDiv.style.color = "#c62828";
                      }
                    }
                  };
                })
                .catch((err) => {
                  midiStatusDiv.textContent =
                    "MIDIデバイスへのアクセスに失敗しました";
                  midiStatusDiv.style.color = "#c62828";
                  console.error("MIDI Access Error:", err);
                });
            } else {
              midiStatusDiv.textContent =
                "このブラウザはMIDIをサポートしていません";
              midiStatusDiv.style.color = "#c62828";
              console.log("MIDIはサポートされていません");
            }
          }

          // エラーハンドリング（initMIDI()の前に追加）
          soundPlayer.loadaudio().catch((error) => {
            console.error("Failed to load sound files:", error);
          });

          initMIDI();
        </script>
  </body>

</html>
